#include <stdio.h>
#include <unistd.h>
/*
 * stdio.h:
 *   fprintf(), stderr などの標準入出力関数を使用するために必要。
 *
 * unistd.h:
 *   fork(), getpid() などの POSIX システムコールを使用するために必要。
 *   Linux/UNIX 系 OS における低レイヤーAPIが定義されている。
 */

int main(void){
   pid_t pid;
   /*
    * pid_t:
    *   プロセスID（PID）を表すための型。
    *   実体は int 系だが、OS依存のため pid_t が使われる。
    */

   int i;
   /*
    * ループ制御用変数。
    */

   fork();
   /*
    * fork():
    *   現在のプロセスを「丸ごと複製」して新しいプロセスを作成する。
    *
    * fork() 実行後の世界：
    *   - 親プロセス（元のプロセス）
    *   - 子プロセス（fork により生成されたプロセス）
    *
    * 両方のプロセスが、fork() の「次の行」から実行を続ける。
    *
    * ※ このコードでは fork() の戻り値を使っていないため、
    *    親・子の区別をしていない点が重要。
    */

   pid = getpid();
   /*
    * getpid():
    *   現在実行中のプロセスの PID（プロセスID）を取得する。
    *
    * fork() 後は、
    *   - 親プロセスと
    *   - 子プロセス
    * がそれぞれ異なる PID を持つ。
    *
    * そのため、この getpid() は
    *   親では「親の PID」
    *   子では「子の PID」
    * をそれぞれ返す。
    */

   for(i = 0; i < 10; i++){
      fprintf(stderr, "PID=%d i=%d\n", pid, i);
      /*
       * 各プロセスが自分の PID と i の値を出力する。
       *
       * fork() によりプロセスが2つ存在するため、
       * この for ループは
       *   - 親プロセスで 10 回
       *   - 子プロセスで 10 回
       * 合計 20 行出力される。
       *
       * どの順序で出力されるかは、
       * OS のスケジューラ次第であり、
       * 毎回同じ順序になるとは限らない。
       */
   }

   return 0;
   /*
    * プログラムの終了。
    *
    * 親・子プロセスはそれぞれ独立して return 0 で終了する。
    * つまり「1つの main が 2 回終了する」状態になる。
    */
}
