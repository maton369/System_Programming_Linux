#include <stdio.h>
#include <unistd.h>
/*
 * stdio.h:
 *   fprintf(), stderr などの標準入出力関数を使用するために必要。
 *
 * unistd.h:
 *   fork() などの POSIX システムコールを使用するために必要。
 *   Linux/UNIX におけるプロセス制御APIが定義されている。
 */

#define N 10
/*
 * N:
 *   ループ回数を表す定数マクロ。
 *   親プロセス・子プロセスの双方で同じ回数だけ
 *   ループを回すために使用される。
 */

int main(void){
   pid_t pid;
   /*
    * pid:
    *   fork() の戻り値を受け取る変数。
    *   型 pid_t はプロセスID（PID）を表すための型。
    *
    * fork() の戻り値の意味：
    *   - 親プロセスでは「子プロセスの PID（正の値）」
    *   - 子プロセスでは「0」
    *   - エラー時は「-1」
    */

   int i;
   /*
    * ループ制御用の変数。
    * fork() によってプロセスが分岐した後は、
    * 親・子それぞれが独立した i を持つ。
    */

   pid = fork();   // 子プロセスの生成
   /*
    * fork():
    *   現在のプロセスを複製し、新しい子プロセスを生成する。
    *
    * fork() 呼び出し後の状態：
    *   - 親プロセスと子プロセスの 2 つが存在する
    *   - 両方のプロセスが fork() の「次の行」から実行を続ける
    *   - メモリ内容は fork 時点で同一（コピーオンライト）
    *
    * この fork() の戻り値 pid を使って、
    * 親プロセスと子プロセスの処理を分岐している。
    */

   if(pid == 0){
      /*
       * pid == 0:
       *   子プロセスでのみ成立する条件。
       *
       * 親プロセスでは pid には「子プロセスの PID」が入るため、
       * この条件は偽になる。
       */

      for(i = 0; i < N; i++){
         fprintf(stderr, "子プロセス i=%d\n", i);
         /*
          * 子プロセス側の処理。
          *
          * 子プロセスが for ループを N 回実行し、
          * 自分が「子プロセス」であることを示すメッセージを出力する。
          */
      }
   }
   else{
      /*
       * pid != 0:
       *   親プロセスで成立する条件。
       *
       * pid には fork() により生成された
       * 子プロセスの PID（正の値）が格納されている。
       */

      for(i = 0; i < N; i++){
         fprintf(stderr, "親プロセス i=%d\n", i);
         /*
          * 親プロセス側の処理。
          *
          * 親プロセスも子プロセスと並行して
          * for ループを N 回実行する。
          *
          * 実行順序は OS のスケジューラに依存するため、
          * 親と子の出力が交互に混ざることもあれば、
          * どちらかが先にまとまって出力されることもある。
          */
      }
   }

   return 0;
   /*
    * プログラムの終了。
    *
    * 親プロセス・子プロセスはそれぞれ独立して
    * return 0 により正常終了する。
    *
    * この時点で、1つの main 関数が
    * 「2つのプロセスで同時に実行されていた」
    * という状態になる。
    */
}
