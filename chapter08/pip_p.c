#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

/*
 * このプログラムは「無名パイプ(pipe)」を使って、
 * 親プロセスと子プロセス（さらに exec で置換された別プログラム pip_c）間で
 * データをやり取りする例である。
 *
 * 目的（全体アルゴリズム）:
 *   1) pipe(fd) で親子が共有する通信路（カーネル内バッファ）を作る
 *   2) 標準入力から単語 word を1つ読む
 *   3) fork() で子プロセスを作る
 *   4) 子は execl() で "pip_c" にプロセス置換し、同じパイプFDを引き継ぐ
 *   5) 親はパイプに word を送り、子の処理完了を wait() で待つ
 *   6) 親は子がパイプに書いた計算結果（整数 n）を読み取って表示する
 *
 * 想定される pip_c の役割（推測）:
 *   - 親から word を受け取る
 *   - word の文字数などを計算して整数 n を作る
 *   - n を親へ返す
 *
 * 重要ポイント:
 *   - pipe は「一方向」通信（write end -> read end）
 *   - fork 後、FD（ファイルディスクリプタ）は親子に複製され同じ番号で使える
 *   - exec しても FD は（close-on-exec でない限り）そのまま引き継がれる
 *   - このコードは「親が exec した子に仕事を投げ、結果を受け取る」UNIX 的分業モデル
 */

int main(){
   pid_t pid;
   /*
    * pid_t:
    *   プロセスID型。
    *
    * fork() の戻り値は:
    *   - 親プロセス: 子の PID（>0）
    *   - 子プロセス: 0
    *   - 失敗: -1
    */

   char line[256], rfd[5], wfd[5], word[256];
   /*
    * line:
    *   stdin から読んだ1行を格納するバッファ。
    *
    * word:
    *   入力行から抽出した単語（空白区切りの1トークン）。
    *
    * rfd, wfd:
    *   pipe() が返した FD（整数）を文字列にして入れるバッファ。
    *   execl() で子プロセスに引数として渡すため「文字列化」する。
    *
    * 注意:
    *   rfd/wfd は 5 バイトしかないため、
    *   FDが4桁程度までしか安全ではない（"1024\0"）。
    *   教材としては十分だが、実務なら余裕を持たせる。
    */

   int n, fd[2], st, ret1, ret2;
   /*
    * fd[2]:
    *   pipe() で作られるFD配列。
    *     fd[0] = 読み口（read end）
    *     fd[1] = 書き口（write end）
    *
    * n:
    *   親がパイプから読み取る整数結果。
    *
    * st:
    *   wait() で子の終了ステータスを受け取る。
    *
    * ret1, ret2:
    *   返り値確認用。
    */

   ret1 = pipe(fd);
   /*
    * pipe(fd):
    *   カーネル内に「パイプバッファ（FIFO）」を作り、
    *   その両端を操作する FD を2つ返す。
    *
    * 図解（概念）:
    *
    *   親/子 write(fd[1])  ---> [ カーネル内パイプバッファ ] ---> read(fd[0]) 親/子
    *
    * 重要:
    *   パイプの実体はユーザ空間ではなく「カーネル内」にある。
    */

   if(ret1 < 0){
      /*
       * pipe 失敗の典型例:
       *   - FD上限に達した
       *   - カーネル資源不足
       */
      perror("pipe");
      exit(1);
   }

   snprintf(rfd, sizeof(rfd), "%d", fd[0]);
   snprintf(wfd, sizeof(wfd), "%d", fd[1]);
   /*
    * FD（整数）を文字列に変換して execl の引数にする。
    *
    * 例:
    *   fd[0] = 3  → rfd = "3"
    *   fd[1] = 4  → wfd = "4"
    *
    * 子側（pip_c）では argv[1], argv[2] を atoi() 等で整数に戻して使う想定。
    */

   fgets(line, sizeof(line), stdin);
   /*
    * 標準入力から1行読み込む。
    * 例:
    *   "apple\n"
    */

   ret1 = sscanf(line, "%s", word);
   /*
    * sscanf(line, "%s", word):
    *   line から空白区切りの先頭トークンを word に取り出す。
    *
    * ret1 > 0:
    *   1個以上のトークンが取れた（成功）
    *
    * ret1 <= 0:
    *   何も取れなかった（空行など）
    */

   if(ret1 > 0){
      /*
       * 入力が取れた場合のみ、子プロセスを作って処理を委譲する。
       */

      pid = fork();
      /*
       * fork():
       *   現在のプロセスを複製して子プロセスを作る。
       *
       * ここが重要:
       *   - 親が持っている FD（fd[0], fd[1]）も子へ複製される
       *   - つまり親子で「同じパイプ」を共有できる
       */

      if(pid == 0){
         /*
          * 子プロセス側:
          *   execl で別プログラム pip_c に置換する。
          *
          * exec が成功すれば、この後の子プロセスは pip_c として動く。
          * つまり「子が pip_c になる」。
          */

         ret2 = execl("pip_c", "pip_c", rfd, wfd, NULL);
         /*
          * execl(file, argv0, argv1, argv2, ..., NULL):
          *
          * ここでは
          *   実行ファイル: "pip_c"
          *   argv[0]     : "pip_c"
          *   argv[1]     : rfd（読み口FD番号の文字列）
          *   argv[2]     : wfd（書き口FD番号の文字列）
          *
          * 「なぜFD番号を渡すのか？」
          *   pip_c 側で read()/write() にどのFDを使うか分かるようにするため。
          *
          * 重要:
          *   exec によりプログラムは置換されるが FD は引き継がれる。
          */

         if(ret2 < 0){
            /*
             * execl が失敗した場合のみここに来る。
             * 例:
             *   - pip_c が見つからない
             *   - 実行権限がない
             */
            exit(1);
         }
      }

      /*
       * ここ以降は親プロセスの処理（pid != 0 の想定）。
       * 親が word を送信し、子の処理を待ち、結果を受信する。
       */

      write(fd[1], word, sizeof(word));
      /*
       * write(fd[1], word, sizeof(word)):
       *   パイプ書き口に word を送る。
       *
       * 注意（重要）:
       *   sizeof(word) は 256 なので、単語が短くても 256 バイト送る。
       *   これは「固定長メッセージ通信」になっている。
       *
       * 実務なら:
       *   write(fd[1], word, strlen(word)+1)
       * のように必要分だけ送ることが多い。
       */

      wait(&st);
      /*
       * wait(&st):
       *   子プロセスが終了するまで待つ。
       *
       * ここで同期が取れるため、
       *   子（pip_c）が結果を書き終えてから親が read() する
       * という順序を保証しやすい。
       *
       * また、子を回収してゾンビ化を防ぐ。
       */

      read(fd[0], &n, sizeof(n));
      /*
       * read(fd[0], &n, sizeof(n)):
       *   パイプ読み口から整数 n を受け取る。
       *
       * 想定される pip_c の動作例:
       *   - word を読み取り
       *   - n = strlen(word) を計算
       *   - write(書き口FD, &n, sizeof(n)) で親へ返す
       */

      fprintf(stderr, "%s <-> %d \n", word, n);
      /*
       * 例:
       *   apple <-> 5
       *
       * word と計算結果 n を対応づけて表示している。
       */

      close(fd[0]);
      close(fd[1]);
      /*
       * 親側でパイプ端点を閉じる。
       *
       * パイプは参照しているプロセス（正確にはFD）が全て閉じると解放される。
       *
       * 一般的には、
       *   - 親は子に送るだけなら read end を閉じる
       *   - 子は読むだけなら write end を閉じる
       * のように「不要な端点を早めに close」して EOF を正しく伝える設計にする。
       * 本コードは教材的に単純化されている。
       */
   }

   return 0;
}

/*
 * 実行例:
 *
 *   入力:
 *     apple
 *
 *   出力:
 *     apple <-> 5
 *
 * ここから「子（pip_c）が単語を受け取り、何らかの整数（例: 文字数）を返している」
 * という通信プロトコルが読み取れる。
 */
