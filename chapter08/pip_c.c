#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

/*
 * このプログラムは、親プロセスから渡された「パイプのFD番号」を使って、
 * パイプ経由で文字列を受け取り、その文字列の長さを計算して親へ返す役割を担う。
 *
 * 想定される利用シーン:
 *   親プロセス側が
 *     1) pipe(fd) でパイプを作成
 *     2) fork() で子を作成
 *     3) 子は execl("pip_c", "pip_c", rfd, wfd, NULL) のように起動される
 *     4) 親は write(fd[1], word, ...) で単語を送る
 *     5) 子(pip_c) は read(rfd, ...) で受信し、strlen() で長さを計算し、
 *        write(wfd, &n, ...) で整数を親へ返す
 *
 * 重要ポイント:
 *   - ここでの rfd / wfd は「ファイルディスクリプタ番号」である
 *   - FD は fork() で親子に引き継がれ、exec() 後も（close-on-execでない限り）維持される
 *   - read/write は「カーネル内パイプバッファ」を介して行われる
 *
 * パイプ構造イメージ（概念図）:
 *
 *     親: write(fd[1], word)  ---> [ カーネル内パイプバッファ ] ---> 子: read(rfd, word)
 *
 *     子: write(wfd, n)       ---> [ カーネル内パイプバッファ ] ---> 親: read(fd[0], n)
 *
 * ※ 注意:
 *   「1本のパイプ」は基本的に一方向通信であり、
 *   1本を双方向に使う設計は衝突・混線の原因になりやすい。
 *   ただし教材では「共有FDで read と write を両方している」例として成立している。
 *   実務では通常「親→子」「子→親」で2本のパイプを用意することが多い。
 */

int main(int argc, char *argv[]){

   char word[256];
   /*
    * 親から送られてくる単語（固定長メッセージ）を受け取るバッファ。
    *
    * 親が write(fd[1], word, sizeof(word)) のように 256 バイト固定で送る前提なので、
    * こちらも sizeof(word) (=256) で read している。
    */

   int n, rfd, wfd;
   /*
    * rfd:
    *   読み込みに使うFD（パイプ読み口のはず）
    *
    * wfd:
    *   書き込みに使うFD（パイプ書き口のはず）
    *
    * n:
    *   word の長さ（strlen 結果）を格納し、親へ返す整数。
    */

   rfd = atoi(argv[1]);
   wfd = atoi(argv[2]);
   /*
    * 親プロセスから execl の引数で渡された FD 番号（文字列）を整数化する。
    *
    * 例:
    *   argv[1] = "3" → rfd = 3
    *   argv[2] = "4" → wfd = 4
    *
    * 注意:
    *   atoi はエラー検出が弱い（不正文字列でも 0 を返すことがある）。
    *   教材では簡略化しているが、実務では strtol を使うことが多い。
    */

   read(rfd, word, sizeof(word));
   /*
    * read(rfd, word, sizeof(word)):
    *   パイプから 256 バイト読み取る。
    *
    * 重要:
    *   read は「必要なバイトが来るまでブロック」する。
    *   つまり親が write するまでここで待つ。
    *
    * また、戻り値（読み取ったバイト数）をチェックしていないため、
    * 途中で切れて届くケースやエラーを厳密に扱っていない。
    */

   n = strlen(word);
   /*
    * strlen(word):
    *   '\0'（ヌル終端）までの文字数を返す。
    *
    * 親が送ったデータが「ヌル終端付きの文字列」であることが前提。
    * 親が固定長256バイト送っていても、
    * word の中に正しく '\0' が含まれていれば strlen は期待通り動く。
    */

   sleep(10);
   /*
    * 10秒待機。
    *
    * 教材として「子の処理が時間を要する」状況を作り、
    * 親側が wait() で待っている間にブロックされることを観察できる。
    *
    * 例:
    *   親が wait() している間、子が sleep で遅延するため、
    *   親はすぐに結果を得られない。
    */

   write(wfd, &n, sizeof(n));
   /*
    * write(wfd, &n, sizeof(n)):
    *   計算した整数 n をパイプに書き込み、親へ返す。
    *
    * n は int 型なので通常 4 バイト（環境依存）。
    * 親は read(fd[0], &n, sizeof(n)) で同じサイズを読む想定。
    *
    * 注意:
    *   送る側と受け取る側で「型サイズ」が一致している前提。
    *   異なる環境間通信では固定幅整数（int32_t等）を使うのが安全。
    */

   close(rfd);
   close(wfd);
   /*
    * FD を閉じる。
    *
    * パイプは参照している FD が全て閉じられると
    * カーネル側の資源が解放される。
    *
    * また、片側が閉じることで相手側の read が EOF を検知できる場合がある。
    */

   return 0;
}
