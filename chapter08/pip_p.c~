## 総評

本コードは、pipe() による無名パイプを使って親子プロセス間で通信し、
子プロセスを exec により別プログラム（pip_c）へ置換して処理を委譲する
典型的な「fork + exec + pipe + wait」構成である。

アルゴリズムとしては、

    1) パイプ生成
    2) 入力取得
    3) fork で子生成
    4) 子は exec で pip_c に置換
    5) 親はパイプへデータ送信
    6) 親は子終了を待つ
    7) 親はパイプから結果受信
    8) 表示して終了

という、UNIX 的なプロセス間分業モデルを非常に明快に示している。

----------------------------------------------------------------

## 全体アルゴリズム（高レベル）

入力された単語 word を子プロセス（pip_c）へ渡し、
pip_c が計算した結果（整数 n）を親が受け取り表示する。

想定される処理内容（例）:

    word = "apple"
    pip_c が n = 5（文字数）を返す
    親が "apple <-> 5" を表示する

----------------------------------------------------------------

## 処理フロー（図解）

    親プロセス
      |
      | pipe(fd)
      |   fd[0]=read end, fd[1]=write end
      |
      | 入力取得 → word 作成
      |
      | fork()
      |   |
      |   +---------------------+
      |                         |
      v                         v
    親（pid!=0）               子（pid==0）
      |                         |
      | write(fd[1], word)      | exec("pip_c", rfd, wfd)
      |                         |  (pip_c が起動)
      | wait()                  |
      |                         | pip_c: read(fd[0], word)
      | read(fd[0], n)          | pip_c: 計算 → write(fd[1], n)
      | print(word <-> n)       |
      | close()                 |
      v                         v
    終了                       終了

ポイント:
・親子は同じパイプ（同じカーネルバッファ）を共有する  
・子は exec で別プログラムになっても FD を引き継いで通信できる  

----------------------------------------------------------------

## パイプの仕組み（図解）

pipe(fd) により、カーネル内にバッファが1つ作られる。

          ┌─────────────────────────┐
fd[1] --->│  カーネル内パイプバッファ  │---> fd[0]
 (write)  └─────────────────────────┘    (read)

・write(fd[1], ...) はバッファへ書き込み
・read(fd[0], ...) はバッファから読み出し

----------------------------------------------------------------

## fork + exec の役割分担

### fork の役割
親プロセスを複製し、子プロセスを作る。

重要:
fork 後、FD は親子に引き継がれる（同じ番号・同じ端点）。

### exec の役割
子プロセスの「中身（プログラム）」を pip_c に置き換える。

重要:
exec 後も FD は維持される（close-on-exec でない限り）。
そのため pip_c からも同じ FD で read/write が可能。

----------------------------------------------------------------

## FD を文字列で渡している理由

execl は引数を文字列として渡すため、
FD（整数）を snprintf で文字列化して渡している。

    rfd = "3"
    wfd = "4"

pip_c 側ではこれを atoi などで整数に戻して使う想定である。

----------------------------------------------------------------

## 同期（wait）の意味

親は wait(&st) を呼び、
子プロセス（pip_c）の終了まで待つ。

これにより、

・子が結果を書き戻す前に親が read して空読みするのを避ける  
・子を回収してゾンビ化を防ぐ  

という2つの効果がある。

----------------------------------------------------------------

## 気になる点（改善余地）

学習用としては成立しているが、実務視点では注意点がある。

1) write(fd[1], word, sizeof(word)) が固定長 256 バイト送信
   ・実際の文字列長だけ送る設計の方が自然
   ・受信側が固定長前提なら問題ないがプロトコルが暗黙的

2) 親子で「使わない端点」を close していない
   ・一般に親は read end を早めに閉じる/子は write end を閉じる等で
     EOF が正しく伝わりデッドロックを避けやすい

3) エラーハンドリングが最低限
   ・fork, read, write の戻り値チェックがない
   ・execl 失敗時に perror があると原因が追いやすい

ただしアルゴリズム理解という観点では、
あえて単純化しているとも解釈できる。

----------------------------------------------------------------

## まとめ

本コードは、

    pipe で通信路を作り
    fork で子を作り
    exec で子に処理を委譲し
    親がデータ送信 → 結果受信する

という UNIX のプロセス分業 + IPC の基本アルゴリズムを
非常に分かりやすく示している。

fork/exec/pipe/wait の連携を学ぶ上で良い基礎例である。
