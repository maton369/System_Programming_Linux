#include <stdio.h>
#include <pthread.h>

#define COUNT 1000000
#define TH_N 5

/*
 * このプログラムは pthread を使って、
 * 1つの共有カウンタ c を複数スレッドで同時にインクリメントする例である。
 *
 * 目的（教材的な狙い）:
 *   - “共有変数を複数スレッドで更新すると何が起こるか” を体験する
 *
 * 期待したい（理想の）結果:
 *   - スレッド数 TH_N=5
 *   - 各スレッドが COUNT=1,000,000 回インクリメント
 *   → 合計は 5,000,000 になってほしい
 *
 * 実際の出力例:
 *   3408161 のように 5,000,000 より小さくなることがある（コメントの実測値）
 *
 * なぜ小さくなるか:
 *   - (*(int*)x)++ は “1命令” ではなく、
 *       1) メモリから読み出す（load）
 *       2) +1 する（add）
 *       3) メモリへ書き戻す（store）
 *     という複数ステップから成るため、スレッド同士で競合が起きる。
 *
 * この競合は「データ競合（data race）」であり、同期が無い場合の動作は未定義になり得る。
 * 学習上は「カウントが欠ける」現象として観測されることが多い。
 *
 * --------------------------------------------------------------------
 * 【インクリメント競合の図解（ロストアップデート）】
 *
 * 共有変数 c が 100 のときに、2スレッドが同時に c++ をすると:
 *
 *   Thread A: load c (=100)
 *   Thread B: load c (=100)
 *   Thread A: add 1 → 101
 *   Thread B: add 1 → 101
 *   Thread A: store 101
 *   Thread B: store 101
 *
 * 結果:
 *   本来 2回増えて 102 になってほしいが、101 のまま（1回分が消える）
 *
 * これが COUNT 回の中で大量に起こるため、最終結果が 5,000,000 より小さくなる。
 *
 * --------------------------------------------------------------------
 * 【対策の典型】
 *
 * - mutex（pthread_mutex_t）で c++ を排他する
 * - atomic（stdatomic.h）を使って原子的にインクリメントする
 *
 * このコードは “わざと同期しない” ことで問題を見せる教材になっている。
 */

void *counter(void *x);

int main(){
   int i = 0;
   int c = 0;                // 複数スレッドで共有して更新するカウンタ
   pthread_t th[TH_N];       // スレッドID配列（TH_N本分）

   /*
    * TH_N 個のスレッドを作成する。
    * 第4引数に &c を渡すことで、全スレッドが同じカウンタを更新する。
    *
    * pthread_create(&th[i], attr, start_routine, arg)
    *   - th[i] にスレッドIDが返る
    *   - start_routine は counter
    *   - arg は &c（void*として渡される）
    */
   for(i = 0; i < TH_N; i++){
      pthread_create(&th[i], NULL, counter, &c);
   }

   /*
    * 作成したスレッドが終了するまで待つ（join）。
    * join しないと main が先に終わってプロセス終了し、スレッドも巻き添えで終わる。
    */
   for(i = 0; i < TH_N; i++){
      pthread_join(th[i], NULL);
   }

   /*
    * 最終的な c を表示する。
    * 同期無しのため、理想値（TH_N*COUNT）より小さくなる可能性がある。
    */
   fprintf(stderr, "%d\n", c);

   return 0;
}

void *counter(void *x){
   int i;

   /*
    * x は void* なので int* にキャストして使う。
    * ここでは main で渡した &c を指している。
    */
   for(i = 0; i < COUNT; i++){
      /*
       * 共有変数に対するインクリメント。
       *
       * 注意（重要）:
       *   ここは排他制御が無いので、複数スレッドが同時に実行すると
       *   ロストアップデートが発生し、カウントが欠ける。
       *
       *   “見た目は1行” でも、CPU命令レベルでは load/add/store に分解される。
       */
      (*(int *)x)++;
   }

   return NULL;
}

/*
実行例（コメント）:

sasayama-no-MacBook-Air:Syoseki sasayama$ time ./thread_counter
3408161

real    0m0.036s
user    0m0.043s
sys     0m0.005s

解釈:
- 期待値 5,000,000 に届いていない → 競合で増分が失われている
- 実行が非常に速いのは、ロックを取っていないため（ただし正しさが壊れている）
*/
