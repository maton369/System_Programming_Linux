#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>
/*
 * stdio.h:
 *   fprintf() を使用するために必要。
 *
 * stdlib.h:
 *   exit() を使用するために必要。
 *
 * sys/wait.h:
 *   wait() を使用するために必要。
 *   子プロセスの終了を回収するAPIを提供する。
 *
 * unistd.h:
 *   fork(), sleep() を使用するために必要。
 */

int main(){
    pid_t pid;
    /*
     * pid:
     *   fork() の戻り値を格納する。
     *
     * fork() の戻り値:
     *   子プロセス  → 0
     *   親プロセス  → 子のPID（正の値）
     *   エラー      → -1
     */

    int st;
    /*
     * st:
     *   wait() によって取得する子プロセスの終了ステータス。
     *   子が exit() した際の情報が格納される。
     */

    pid = fork();
    /*
     * fork():
     *   現在のプロセスを複製する。
     *
     * 実行後は
     *   親プロセス
     *   子プロセス
     * の2つが存在する。
     */

    if(pid == 0){
        /*
         * 子プロセス側の処理。
         */

        exit(0);
        /*
         * 子プロセスを即座に正常終了させる。
         *
         * ここで子は終了するが、
         * 親がまだ wait() を呼んでいない場合、
         * 子は「ゾンビプロセス」状態になる。
         *
         * ゾンビプロセスとは:
         *   実行は終了しているが、
         *   親が終了情報を回収していないため
         *   プロセス表にエントリが残っている状態。
         */
    }
    else{
        /*
         * 親プロセス側の処理。
         */

        sleep(20);
        /*
         * 親プロセスを20秒間停止させる。
         *
         * この間、
         * 子プロセスはすでに終了しているが、
         * 親が wait() を呼んでいないため
         * 子はゾンビ状態になる。
         *
         * この20秒間に `ps` コマンドを実行すると、
         * 子プロセスが "Z" 状態で確認できる。
         */

        wait(&st);
        /*
         * wait():
         *   終了した子プロセスを回収する。
         *
         * これにより、
         *   - ゾンビプロセスが解消される
         *   - 子の終了ステータスが st に格納される
         *
         * wait() を呼ばないと、
         * 子の終了情報は回収されず、
         * ゾンビが残り続ける。
         */

        fprintf(stderr,"正常終了\n");
        /*
         * 子プロセスの終了が回収された後に表示。
         *
         * ここでようやく
         * 親子関係のライフサイクルが完了する。
         */
    }

    return 0;
    /*
     * 親プロセスが終了。
     */
}
