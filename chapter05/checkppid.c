#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
/*
 * stdio.h:
 *   fprintf(), getchar() を使用するために必要。
 *
 * stdlib.h:
 *   exit() を使用するために必要。
 *
 * unistd.h:
 *   fork(), sleep() を使用するために必要。
 */

int main(){
    pid_t pid;
    /*
     * pid:
     *   fork() の戻り値を格納する。
     *
     * fork() の戻り値の意味：
     *   子プロセス  → 0
     *   親プロセス  → 子のPID（正の値）
     *   エラー      → -1
     */

    pid = fork();
    /*
     * fork():
     *   現在のプロセスを複製する。
     *
     * fork() 後は
     *   親プロセス
     *   子プロセス
     * の2つが存在する。
     */

    if(pid == 0){
        /*
         * 子プロセス側の処理。
         */

        sleep(20);
        /*
         * 子は20秒間スリープする。
         *
         * この間に親が先に終了すると、
         * 子は「孤児プロセス（orphan process）」になる。
         *
         * 孤児プロセスとは：
         *   親が終了した後も生存している子プロセス。
         *
         * Linux では孤児プロセスは init（PID=1）に
         * 自動的に引き取られる。
         */

        fprintf(stderr,"子プロセス終了\n");
        /*
         * 子が20秒後に目覚めて出力。
         * この時点では親が既に終了している可能性が高い。
         */

        exit(0);
        /*
         * 子プロセスの正常終了。
         */
    }
    else{
        /*
         * 親プロセス側の処理。
         */

        getchar();
        /*
         * ユーザー入力待ち。
         *
         * Enter が押されると親は終了する。
         *
         * ここで Enter を早めに押すと、
         * 子がまだ sleep 中のまま
         * 親だけが終了する。
         *
         * その結果、子は孤児プロセスになる。
         */

        fprintf(stderr,"親プロセス終了\n");
        /*
         * 親が終了することを表示。
         *
         * wait() を呼んでいないため、
         * 子を回収する処理は行っていない。
         */
    }

    return 0;
    /*
     * 親プロセスはここで終了する。
     *
     * 子がまだ実行中の場合、
     * 子は init プロセスに引き取られ、
     * 親を持たない状態で動作を続ける。
     */
}
