#include <stdio.h>
#include <unistd.h>
/*
 * stdio.h:
 *   fprintf(), stderr などの標準入出力関数を使用するために必要。
 *
 * unistd.h:
 *   execl() などの exec 系システムコールを使用するために必要。
 *   exec 系は Linux/UNIX における「プロセス置換」を行うAPI。
 */

int main(void){
   fprintf(stderr,"execl実行前\n");
   /*
    * この行は、現在のプロセス（このプログラム自身）が
    * まだ通常通り実行されていることを示す。
    *
    * ここでは単に「execl を呼ぶ前」であることを
    * 観測用に出力している。
    */

   execl("/bin/ls", "/bin/ls", "-l", NULL);
   /*
    * execl():
    *   現在のプロセスを、新しいプログラムで「完全に置き換える」。
    *
    * 引数の意味：
    *   第1引数 "/bin/ls"
    *     - 実行するプログラムのパス
    *
    *   第2引数 "/bin/ls"
    *     - argv[0] に渡される文字列（慣例的にプログラム名）
    *
    *   第3引数 "-l"
    *     - argv[1] に渡される引数
    *
    *   最後の NULL
    *     - 引数リストの終端を示す（必須）
    *
    * 実行されるプログラムの視点では、
    *   argv[0] = "/bin/ls"
    *   argv[1] = "-l"
    * という状態になる。
    *
    * 【最重要ポイント】
    *   execl() が成功した場合、
    *   この関数は「戻ってこない」。
    *
    *   現在のプロセスの
    *     - メモリ空間
    *     - プログラムコード
    *     - スタック
    *     - ヒープ
    *   がすべて /bin/ls のものに置き換えられる。
    *
    *   PID は変わらない点が fork() との最大の違い。
    */

   fprintf(stderr,"execl実行後\n");
   /*
    * この行は、execl() が「失敗した場合」にのみ実行される。
    *
    * execl() が成功した場合、
    * この行に制御が戻ることは絶対にない。
    *
    * 実務では、この直後に perror() などを使って
    * エラー内容を出力するのが定石。
    */

   return 0;
   /*
    * プログラムの終了。
    *
    * 通常は execl() が成功すればここには到達しない。
    * 到達した場合は「ls の実行に失敗した」ことを意味する。
    */
}
