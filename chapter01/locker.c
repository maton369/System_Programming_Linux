#include <stdio.h>
/*
 * stdio.h:
 *   標準入出力ライブラリ。
 *   fprintf(), printf(), stderr などの宣言が含まれる。
 *
 *   Linux/UNIX では標準出力(stdout)・標準エラー(stderr)は
 *   プロセス生成時にカーネルがファイルディスクリプタとして割り当てる。
 */

int main(){
    int sato;
    /*
     * 通常の整数型変数。
     * main関数内で宣言されているため、スタック領域に確保される。
     *
     * Linuxでは、関数呼び出し時に
     *   - スタックフレームが作られ
     *   - ローカル変数はその中に配置される
     */

    sato = 100;
    /*
     * sato に整数値 100 を代入。
     * この時点で、スタック上のメモリ領域に
     * 「100」という値が書き込まれる。
     */

    fprintf(stderr, "sato=%d\n", sato);
    /*
     * fprintf:
     *   指定した出力先(FILE*)にフォーマット付きで出力する関数。
     *
     * stderr:
     *   標準エラー出力。
     *   通常 stdout と分離されており、
     *   リダイレクト時にも即時出力されることが多い。
     *
     * デバッグ用途では stdout より stderr を使うのが定石。
     */

    int *p;
    /*
     * int型へのポインタ変数 p。
     *
     * 「p は int 型の値そのものではなく、
     *   int 型の値が格納されているメモリのアドレスを保持する」
     *
     * この時点では p の中身（アドレス）は未定義。
     * 初期化前に使うと未定義動作になる。
     */

    p = &sato;
    /*
     * & 演算子:
     *   変数 sato の「メモリアドレス」を取得する。
     *
     * ここで行われていること:
     *   - sato がスタック上のどこに置かれているか
     *   - そのアドレスを p に代入
     *
     * p ──▶ sato (100)
     */

    fprintf(stderr, "*p=%d\n", *p);
    /*
     * * 演算子（間接参照）:
     *   ポインタ p が指している「先のメモリ」に格納された値を読む。
     *
     * 処理の流れ:
     *   1. p に入っているアドレスを取得
     *   2. そのアドレスのメモリ内容を読み出す
     *   3. int として解釈し出力
     *
     * 結果として *p は sato と同じ値（100）になる。
     */

    return 0;
    /*
     * main の戻り値。
     * 0 は「正常終了」を意味する。
     *
     * Linuxではこの値がプロセスの終了コードとして
     * 親プロセス（シェルなど）に渡される。
     */
}
