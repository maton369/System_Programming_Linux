#include <stdio.h>
/*
 * stdio.h:
 *   標準入出力ライブラリ。
 *   fprintf(), stderr などの宣言が含まれる。
 *
 * stderr は標準エラー出力であり、
 * デバッグ用の出力先としてよく使われる。
 */

int main(){
   int i, ito[5];
   /*
    * i:
    *   ループ制御用の整数変数。
    *
    * ito[5]:
    *   int 型の配列。要素数は 5。
    *   main 関数内で宣言されているため、
    *   配列全体はスタック領域に連続して確保される。
    *
    * メモリ上のイメージ（概念）:
    *   ito[0], ito[1], ito[2], ito[3], ito[4]
    *   が連続したアドレスに並ぶ。
    */

   for(i = 0; i < 5; i++){
      ito[i] = i + 10;
      /*
       * 配列の各要素に値を代入。
       *
       * i = 0 → ito[0] = 10
       * i = 1 → ito[1] = 11
       * i = 2 → ito[2] = 12
       * i = 3 → ito[3] = 13
       * i = 4 → ito[4] = 14
       *
       * 配列名 ito は「先頭要素 ito[0] のアドレス」を
       * 暗黙的に表すことがあるが、
       * ここでは通常の配列アクセスを行っている。
       */
   }

   for(i = 0; i < 5; i++){
      fprintf(stderr, "ito[%d]=%d\n", i, ito[i]);
      /*
       * 各配列要素の値を標準エラー出力に表示。
       *
       * ito[i] は、
       *   *(ito + i)
       * と等価な表現であり、
       * 実際にはポインタ演算として処理される。
       */
   }

   int *p, *q;
   /*
    * p, q:
    *   int 型へのポインタ変数。
    *
    * どちらも「int が置かれているメモリのアドレス」
    * を保持するための変数であり、
    * int の値そのものを保持するわけではない。
    */

   p = &ito[1];
   /*
    * &ito[1]:
    *   配列 ito の 1 番目の要素（ito[1]）のアドレスを取得。
    *
    * ここで p は、
    *   「配列の 2 番目の要素を指すポインタ」
    * になる。
    */

   fprintf(stderr, "*p=%d\n", *p);
   /*
    * *p:
    *   p が指しているメモリ位置の中身を読み取る。
    *
    * p → ito[1] を指しているため、
    * *p の値は ito[1] と同じ（11）になる。
    */

   q = ito;
   /*
    * 配列名 ito は、
    *   「ito[0] のアドレス」
    * として評価される。
    *
    * つまりこの代入は、
    *   q = &ito[0];
    * と等価である。
    *
    * ここが「配列とポインタが密接に関係している」
    * と言われる理由の核心。
    */

   fprintf(stderr, "*q=%d\n", *q);
   /*
    * q は ito[0] を指しているため、
    * *q は配列の先頭要素の値になる。
    *
    * 結果:
    *   *q == ito[0] == 10
    */

   return 0;
   /*
    * プログラムの正常終了。
    * 戻り値 0 は OS に対して
    * 「正常に終了した」ことを示す。
    */
}
